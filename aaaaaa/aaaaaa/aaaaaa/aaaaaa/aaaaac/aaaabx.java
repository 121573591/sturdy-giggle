package aaaaaa.aaaaaa.aaaaaa.aaaaaa.aaaaac;

import org.jetbrains.annotations.NotNull;

public final class aaaaaa/aaaaaa/aaaaaa/aaaaaa/aaaaac/aaaabx {
  @NotNull
  public static final aaaaaa/aaaaaa/aaaaaa/aaaaaa/aaaaac/aaaabx 我草你怎么反编译我模组aaaaaa = new aaaaaa/aaaaaa/aaaaaa/aaaaaa/aaaaac/aaaabx();
  
  private static boolean 我草你怎么反编译我模组aaaaab;
  
  private static long 我草你怎么反编译我模组aaaaac;
  
  public final boolean 你为什么要破解我的代码aaaaaa() {
    return 我草你怎么反编译我模组aaaaab;
  }
  
  public final void 你为什么要破解我的代码aaaaab(boolean paramBoolean) {
    我草你怎么反编译我模组aaaaab = paramBoolean;
  }
  
  public final long 你为什么要破解我的代码aaaaac() {
    return 我草你怎么反编译我模组aaaaac;
  }
  
  public final void 你为什么要破解我的代码aaaaad(long paramLong) {
    我草你怎么反编译我模组aaaaac = paramLong;
  }
  
  public final int 你为什么要破解我的代码aaaaae() {
    return (我草你怎么反编译我模组aaaaab && System.currentTimeMillis() < 我草你怎么反编译我模组aaaaac) ? 2 : 1;
  }
  
  public final void 你为什么要破解我的代码aaaaaf(int paramInt) {
    long l = System.currentTimeMillis();
    我草你怎么反编译我模组aaaaab = true;
    if (l < 我草你怎么反编译我模组aaaaac) {
      long l1 = (我草你怎么反编译我模组aaaaac - l) / 1000L;
      我草你怎么反编译我模组aaaaac = l + (l1 + paramInt) * 1000L;
    } else {
      我草你怎么反编译我模组aaaaac = l + paramInt * 1000L;
    } 
  }
  
  public final boolean 你为什么要破解我的代码aaaaag() {
    if (我草你怎么反编译我模组aaaaab && System.currentTimeMillis() >= 我草你怎么反编译我模组aaaaac)
      我草你怎么反编译我模组aaaaab = false; 
    return 我草你怎么反编译我模组aaaaab;
  }
  
  public final int 你为什么要破解我的代码aaaaah() {
    return !你为什么要破解我的代码aaaaag() ? 0 : (int)((我草你怎么反编译我模组aaaaac - System.currentTimeMillis()) / 1000L);
  }
}
